#!/bin/sh

# [K]2022
# https://github.com/kongfl888

P1=${1}
Job=9
#0N1F-1I
uprule=0
upip=0
updns=0
dht=0

Helpthis() {
DATE_HMS=`date +%H:%M:%S`
DATE_Y=`date +%Y`
DATE="$DATE_Ymd $DATE_HMS"
echo "
Hi Master, I'm your dnshelper. You can use me in the following ways.

usage: rulesmaker [OPTION]
    -h,--help       display this help and exit.
    -f,--force      force update
    -u,--update     This only update dns rules.
    -i,--ip         This only update ip rule.
    -d,--dns        This only update your dns profile.
    -s,--stop       stop and clear.

It is juest a part of me. You still need a luci application.
Thank you for coming to look at me. I'm very happy.
By MY-Dnshelper on $DATE

[K] $DATE_Y
You can contact my Founder via this link: https://github.com/kongfl888
"
exit 0
}

case $P1 in
	"-h"|"--help"|"-H")
	Helpthis
	;;
	"-s"|"--stop"|"-S")
	Job=0
	;;
	"-f"|"--force"|"-F")
	Job=1
	uprule=1
	upip=1
	updns=1
	;;
	"-u"|"--update"|"-U")
	Job=2
	uprule=1
	upip=0
	updns=0
	;;
	"-i"|"--ip"|"-I")
	Job=3
	uprule=-1
	upip=1
	updns=0
	;;
	"-d"|"--dns"|"-D")
	Job=4
	uprule=-1
	upip=0
	updns=1
	;;
	*)
	Job=9
	uprule=0
	upip=1
	updns=1
	;;
esac

source /usr/share/my-dnshelper/comm
sSname="$(basename $0)"

if [ $(pgrep -f ${sSname}|wc -l) -gt 2 ];then
	sleep 15s
	if [ $(pgrep -f ${sSname}|wc -l) -gt 2 ];then
		echo "`eval $D` An instance is running!"
		exit 1
	fi
fi
[ -f $DPath ] && rm -f $DPath
[ ! -d $DPath ] && mkdir -p $DPath

check_wgetcurl(){
	which curl >/dev/null && downloader="curl --retry 3 --connect-timeout 20 -m 80 -kLfso" && return
	which wget-ssl >/dev/null && downloader="wget-ssl --no-check-certificate -t 3 -T 20 -q -O" && return
	[ -z "$1" ] && opkg update || (echo error opkg && exit 1)
	[ -z "$1" ] && (opkg remove wget wget-nossl --force-depends &&  opkg install wget-ssl ; check_wgetcurl 1 ; return)
	[ "$1" == "1" ] && (opkg install curl ; check_wgetcurl 2 ; return)
	echo error curl and wget && exit 1
}

clean_rules(){
	[ -s ${1} ] || return
	local fu_new=${1}
	sed -i -e '/127.0.0.1 #/d' -e '/127.0.0.1 !/d' -e 's:#.*::' -e 's:!.*::' -e 's/\$important//g' -e 's/[ \t]*$//g' -e 's/^[ \t]*//g' -e '/\*/d' -e '/^$/d' $fu_new
	sed -i -r -e 's/^::[1-9]?/0.0.0.0/' -e '/:/d' $fu_new
	sed -i "s/\r//g" $fu_new
	sed -i -r -e "s/\t/ /g" -e "s/  / /g" $fu_new
}

clean_hosts(){
	[ -s ${1} ] || return
	sed -i -e '/\sip6-localhost/d' -e '/\sip6-loopback/d' -e '/\sip6-allnodes/d'  -e '/\sip6-allrouters/d' -e '/ 0.0.0.0/d' -e '/255.255.255.255/d' -e '/ local/d' ${1}
}

get_domain_b()
{
	[ -s ${1} ] || return
	cat ${1} | grep -E "^\|\|.*\^\s*$" | grep -oE "[a-zA-Z0-9][a-zA-Z0-9\-]{0,62}(\.[a-zA-Z0-9][a-zA-Z0-9\-]{0,62})+" >> ${2}
}

get_domain_w()
{
	[ -s ${1} ] || return
	cat ${1} | grep -E "^\@\@\|\|.*\^\s*$" | grep -oE "[0-9a-zA-Z][0-9a-zA-Z\-]+\.\S*[0-9a-zA-Z]+" >> ${2}
}

get_domain_h()
{
	[ -s ${1} ] || return
	cat ${1} | grep -E "^[0-9]+(\.[0-9]+){3}\s+" | grep -oE "[0-9a-zA-Z][0-9a-zA-Z\-]+\.\S*[0-9a-zA-Z]+" >> ${2}
}

get_domain(){
	[ -s ${1} ] || return
	cat ${1} | grep -oE "^[0-1a-zA-Z][0-1a-zA-Z\-]+(\.[0-9a-zA-Z\-]+)+$" >> ${2}
}

get_hosts(){
	[ -s ${1} ] || return
	cat ${1} | grep -E "^[0-9]+(\.[0-9]+){3}\s+[a-zA-Z0-9][a-zA-Z0-9\-]{0,62}(\.[a-zA-Z0-9][a-zA-Z0-9\-]{0,62})+\s*$" >> ${2}
}

get_server(){
	[ -s ${1} ] || return
	cat ${1} | grep -oE "^server=\/.*\/[0-9]+(\.[0-9]+){3}(#[0-9]+)?\s*" >> ${2}
}

get_ipset(){
	[ -s ${1} ] || return
	cat ${1} | grep -oE "^ipset=\/.*\/[0-9a-zA-Z]+\s*" >> ${2}
}

get_ip4s(){
	[ -s ${1} ] || return
	grep -E "^[0-9]+(\.[0-9]+){3}(#[0-9]+)?\s*$" ${1} >> ${2}
}

get_ip46s(){
	[ -s ${1} ] || return
	grep -E "^[0-9a-fA-F:]+[0-9\.]*(#[0-9]+)?\s*$" ${1} >> ${2}
}

get_https(){
	[ -s ${1} ] || return
	grep -E "^https:\/\/.*" ${1} >> ${2}
}

conv_domainc(){
	[ -s ${1} ] || return
	local ptwo=${2}
	local c=0
	if [ -z "${2}" -o "${1}" = "${2}" ]; then
		ptwo="/tmp/helpercdd.txt"
		[ -f $ptwo ] && rm -f $ptwo
		c=1
		touch $ptwo
	fi
	cat ${1} | sed -e 's:^:address=/:' -e 's:$:/:' >> $ptwo
	[ $? -ne 0 ] && echo "${1} | ${2}"
	if [ $c -eq 1 ];then
		cat $ptwo > ${1}
		rm -f $ptwo
	fi
}

conv_hostsc(){
	[ -s "${1}" ] || return
	local pone=${1}
	local ptwo=${2}
	local c=0
	if [ -z "$ptwo" -o "$pone" = "$ptwo" ]; then
		ptwo="/tmp/helpercdd.txt"
		[ -f "$ptwo" ] && rm -f $ptwo
		c=1
		touch $ptwo
	fi

	awk '/^[0-9]/ {printf "address=/%s/%s\n",$2,$1};/^#/;/^$/' $pone | grep "address=" | sed -e '/\/\//d' -e '/=\/$/d' >> $ptwo
	[ $? -ne 0 ] && echo "${1} | ${2}" && cp -f $pone  /tmp/dt_helper.txt
	if [ $c -eq 1 ];then
		cat $ptwo > ${1}
		rm -f $ptwo
	fi
}

conv_ipdnsc(){
	[ -s ${1} ] || return
	local ptwo=${2}
	local c=0
	if [ -z "${2}" -o "${1}" = "${2}" ]; then
		ptwo="/tmp/helpercdd.txt"
		[ -f $ptwo ] && rm -f $ptwo
		c=1
		touch $ptwo
	fi
	cat ${1} | sed -e 's:^:nameserver :'  >> $ptwo
	[ $? -ne 0 ] && echo "${1} | ${2}"
	if [ $c -eq 1 ];then
		cat $ptwo > ${1}
		rm -f $ptwo
	fi
}

# ip 4or6
str_bootstrap(){
	local a=""
	local c=0
	for i in $(cat $1);do
		if [ "$2" == "4" ];then
			echo $i | grep -q ":" && continue
		fi
		if [ "$2" == "6" ];then
			echo $i|grep -qE "^[0-9]+\." && continue
		fi
		if [ $(ping_ip $i) -eq 0 ];then
			[ -n "$i" ] || continue
			let c++
			if [ -z "$a" ]; then
				a="$i"
			else
				a="$a,$i"
			fi
		fi
		[ $c -eq 4 ] && break
	done
	echo "$a"
}

int_port(){
	local p=$1
	local i=0
	[ -z "$p" ] && p="5053"
	while [ $i -lt 20 ]; do
		let i++
		if [ $(netstat -nutlp 2>/dev/null | grep ":$p\s" -c) -eq 0 ]; then
			break
		else
			let p++
		fi
	done
	echo $p
}

lite_file(){
	# 1d 2c
	[ -s ${1} ] || return
	[ -s ${2} ] || return
	rm -f /tmp/sfile2.txt
	conv_domainc ${1} "/tmp/sfile2.txt"
	awk 'NR==FNR{a[$0]++;next}!($0 in a){print}' /tmp/sfile2.txt ${2} > /tmp/lfile1.txt || echo ""
	sort_file /tmp/lfile1.txt
	cp -f /tmp/lfile1.txt ${2}
	rm -f /tmp/lfile1.txt /tmp/sfile2.txt
}

fu_ios(){
	[ -s ${1} ] || return
	[ "$bio" = "1" ] || return

	cat <<-EOF >> ${1}
address=/mesu.apple.com/
EOF

}

fu_ga(){
	[ -s ${1} ] || return
	[ "$bga" = "1" ] || return

	cat <<-EOF >> ${1}
address=/17173.com/
address=/4399.com/
address=/9game.cn/
address=/duowan.com/
address=/game.163.com/
address=/game.oppomobile.com/
address=/game.qq.com/
address=/game.vivo.com.cn/
address=/game.xiaomi.com/
address=/game.yy.com/
address=/gamex.mobile.youku.com/
address=/igame.qq.com/
address=/ingame.qq.com/
address=/mkey.163.com/
address=/pcgames.com.cn/
address=/play.163.com/
address=/pvp.qq.com/
address=/pwesports.cn/
address=/steamchina.con/
address=/steampowered.com/
address=/update.netease.com/
address=/wan.baidu.com/
address=/wan.yy.com/
address=/wmpvp.com/
address=/wmsjsteam.com/
address=/xyx.hao123.com/
address=/youxi.baidu.com/
EOF

}

fu_short(){
	[ -s ${1} ] || return
	[ "$bsh" = "1" ] || return

	cat <<-EOF >> ${1}
address=/amemv.com/
address=/baijiahao.baidu.com/
address=/bytedance.com/
address=/bytednsdoc.com/
address=/byteimg.com/
address=/danuoyi.alicdn.com/
address=/doupai.cc/
address=/douyin.com/
address=/douyinpic.com/
address=/douyinvod.com/
address=/ergengtv.com/
address=/gifshow.com/
address=/gdatacube.net/
address=/huoshan.com/
address=/iesdouyin.com/
address=/ixigua.com/
address=/ixiguavideo.com/
address=/ksapisrv.com/
address=/ksyun.com/
address=/kuaishou.com/
address=/kuaishoupay.com/
address=/live.xycdn.com/
address=/meipai.com/
address=/miaopai.com/
address=/pearvideo.com/
address=/pstatp.com/
address=/qupai.me/
address=/snssdk.com/
address=/tiktok.com/
address=/tiktokv.com/
address=/vimg.9game.cn/
address=/v.kandian.qq.com/
address=/v.weishi.qq.com/
address=/xiongzhang.baidu.com/
address=/youliao.xunlei.com/
address=/yximgs.com/
address=/yy.com/
address=/zijieapi.com/
EOF

}

fu_google(){
	[ -s ${1} ] || return
	[ "$bgg" = "1" ] || return

	cat <<-EOF >> ${1}
address=/google.cn/
address=/google.com/
address=/google.com.hk/
address=/google.com.tw/
address=/google.co.jp/
address=/google.co.uk/
address=/googleapis.com/
address=/googleadservices.com/
address=/gstatic.com/
address=/googlebot.com/
address=/googlechinawebmaster.com/
address=/googleplay.com/
address=/googleapps.com/
address=/googleapis.cn/
address=/agoogleaday.com/
address=/googlegroups.com/
address=/googleplus.com/
address=/googlevideo.com/
address=/google-analytics.com/
address=/igoogle.com/
address=/ieonline.microsoft.com/
EOF

}

downurl(){
	local fu_new="$TPath/fu_new.conf"
	rm -rf $TPath
	[ -f $SPath ] && rm -f $SPath
	mkdir -p $SPath $TPath
	rm -f $SPath/url
	touch $TPath/url
	for i in $UF;do
		[ -n "$i" ] || continue
		$downloader $fu_new $i
		if [ -s $fu_new ]; then
			echo "`eval $D` Rules download successfully - $i"
		else
			echo "`eval $D` Failed to download - $i"
			continue
		fi
		clean_rules $fu_new
		if grep -q "^address=" $fu_new;then
			cat $fu_new >> $TPath/rules.conf
		elif grep -q -e "^0.0.0.0 " -e "^127.0.0.1 " $fu_new;then
			cat $fu_new >> $TPath/host
		elif ! grep -q -e "|" -e "@" $fu_new;then
			conv_domainc $fu_new $TPath/rules.conf
		else
			cat $fu_new | grep ^\|\|[^\*]*\^$ | grep -Ev "^\|\|[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}*" | sed -e 's:||:address=/:' -e 's:\^.*:/:' >> $TPath/rules.conf
		fi
		echo $i >> $TPath/url
		rm -f $fu_new
	done
	if [ -s $TPath/host ];then
		clean_hosts $TPath/host
		conv_hostsc $TPath/host $TPath/rules.conf
		sed -i -e 's/127.0.0.1//g' -e 's/0.0.0.0//g' $TPath/rules.conf
	fi
	[ -s $TPath/rules.conf ] && sed -i -e 's:/127.0.0.1$:/:' -e 's:/0.0.0.0$:/:' $TPath/rules.conf && sort_file $TPath/rules.conf
	[ -s $TPath/url ] && sort_file $TPath/url
	if [ -s $TPath/rules.conf ];then
		echo "`eval $D` Filter rules get successfully."
		rm -f $TPath/host $SPath/failed
		[ ! -d $SPath ] && mkdir -p $SPath
		ifc=$(get_count $TPath/rules.conf)
		cp -a -f $TPath/* $SPath
	else
		echo "`eval $D` Filter rules get failed."
		echo "failed" > $RPath/failed
	fi
	rm -rf $TPath
}

downallow(){
	local fu_new="$TPath/fu_newa.conf"
	rm -rf $TPath
	[ -f $SPath ] && rm -f $SPath
	mkdir -p $SPath $TPath
	rm -f $SPath/aurl
	touch $TPath/aurl
	for i in $UA;do
		[ -n "$i" ] || continue
		$downloader $fu_new $i
		if [ -s $fu_new ]; then
			echo "`eval $D` Allow list download successfully - $i"
		else
			echo "`eval $D` Failed to download - $i"
			continue
		fi
		clean_rules $fu_new
		get_domain_w "$fu_new" "$TPath/white.txt"
		get_domain_h "$fu_new" "$TPath/white.txt"
		get_domain "$fu_new" "$TPath/white.txt"
		echo $i >> $TPath/aurl
		rm -f $fu_new
	done
	if [ -s $TPath/white.txt ]; then
		sed -i -r '/^([0-9]+\.){3}[0-9+]/d' $TPath/white.txt
		sort_file $TPath/white.txt
	fi
	[ -s $TPath/aurl ] && sort_file $TPath/aurl
	if [ -s $TPath/white.txt ];then
		echo "`eval $D` Allow list get successfully."	
		[ ! -d $SPath ] && mkdir -p $SPath
		iac=$(get_count $TPath/white.txt)
		cp -a -f $TPath/* $SPath
	else
		[ -s $TPath/aurl ] && echo "`eval $D` Allow list get failed."
	fi
	rm -rf $TPath
}

downhosts(){
	local fu_new="$TPath/fu_newh.conf"
	rm -rf $TPath
	[ -f $SPath ] && rm -f $SPath
	mkdir -p $SPath $TPath
	rm -f $SPath/hurl
	touch $TPath/hurl
	for i in $UH;do
		[ -n "$i" ] || continue
		$downloader $fu_new $i
		if [ -s $fu_new ]; then
			echo "`eval $D` Hosts list download successfully - $i"
		else
			echo "`eval $D` Failed to download - $i"
			continue
		fi
		clean_rules $fu_new
		get_hosts "$fu_new" "$TPath/myhosts"
		echo $i >> $TPath/hurl
		rm -f $fu_new
	done
	if [ -s $TPath/myhosts ]; then
		conv_hostsc $TPath/myhosts $TPath/hosts.conf
		sort_file $TPath/hosts.conf
	fi
	[ -s $TPath/hurl ] && sort_file $TPath/hurl
	if [ -s $TPath/hosts.conf ];then
		echo "`eval $D` Hosts list get successfully."
		ihc=$(get_count $TPath/myhosts)
		rm -f "$TPath/myhosts"
		[ ! -d $SPath ] && mkdir -p $SPath
		cp -a -f $TPath/* $SPath
	else
		[ -s $TPath/hurl ] && echo "`eval $D` Hosts list get failed."
	fi
	sh /usr/share/my-dnshelper/ghosts
	if [ -s $EPath/github.mdhp ];then
		touch $SPath/hosts.conf
		cat $EPath/github.mdhp >> $SPath/hosts.conf
		sort_file $SPath/hosts.conf
	fi

	rm -rf $TPath
}

user_rules(){
	local u_cr="$EPath/user.mdhp"
	local fu_new="$TPath/user_newu"
	rm -rf $TPath
	[ -f $SPath ] && rm -f $SPath
	mkdir -p $SPath $TPath
	cp -f $u_cr $fu_new
	[ -s $u_cr ] || return
	clean_rules $fu_new
	get_domain_b $fu_new $TPath/user.conf
	get_domain $fu_new $TPath/user.conf
	get_domain_w $fu_new $TPath/uwhite.txt
	get_hosts $fu_new $TPath/uhosts.conf
	[ -s $TPath/uhosts.conf ] && grep -E "^127.0.0.1|^0.0.0.0" $TPath/uhosts.conf > $TPath/uhosts
	if [ -s $TPath/uhosts.conf ]; then
		sed -i -e '/127.0.0.1/d' -e '/0.0.0.0/d' $TPath/uhosts.conf
		get_domain_h $TPath/uhosts.conf $TPath/uwhite.txt
		conv_hostsc $TPath/uhosts.conf
	fi
	if [ -s $TPath/uwhite.txt ];then
		sed -i -r '/^([0-9]+\.){3}[0-9+]/d' $TPath/uwhite.txt
		sort_file $TPath/uwhite.txt
	fi
	if [ -s $TPath/user.conf ];then
		conv_domainc $TPath/user.conf
		sort_file $TPath/user.conf
		lite_file $TPath/uwhite.txt $TPath/user.conf
	fi
	fu_ga $TPath/user.conf
	fu_short $TPath/user.conf
	fu_ios $TPath/user.conf
	fu_google $TPath/user.conf
	get_server $fu_new $TPath/uhosts.conf
	get_ipset $fu_new $TPath/uhosts.conf
	[ -s $TPath/user.conf ] && sort_file $TPath/user.conf
	[ -s $TPath/uhosts.conf ] && sort_file $TPath/uhosts.conf
	[ -s $TPath/uhosts ] && sort_file $TPath/uhosts
	[ -s $fu_new ] && echo "`eval $D` User rule reading completed."
	[ ! -d $SPath ] && mkdir -p $SPath
	rm -f $fu_new
	cp -a -f $TPath/* $SPath
	rm -rf $TPath
}

user_do53(){
	local u_cr="$EPath/dns.mdhp"
	local fu_new="$TPath/user_dns"
	rm -rf $TPath
	[ -f $SPath ] && rm -f $SPath
	mkdir -p $SPath $TPath
	[ -s $u_cr ] || return
	get_ip46s $u_cr $fu_new
	[ -s $fu_new ] || return
	conv_ipdnsc $fu_new $resolvconf
	sort_file $resolvconf
	if [ -s $fu_new ]; then
		echo "`eval $D` Custom DNS is set."
		[ "$(check_masq53)" == "1" ] && echo "`eval $D` But dnsmasq not work on port 53. Please check page DHCP/DNS."
	else
		echo "`eval $D` Please check DNS Setting."
	fi
	rm -f $fu_new
	rm -rf $TPath
}

user_doh(){
	local e=0
	local u_cr="$EPath/dns.mdhp"
	local b_cr="$EPath/bootstrap.mdhp"
	local fu_new="$TPath/user_doh"
	local str_4b=""
	local str_6b=""
	local dohon=0
	rm -rf $TPath
	[ -f $SPath ] && rm -f $SPath
	mkdir -p $SPath $TPath
	[ -s $u_cr ] || return
	get_https $u_cr $fu_new
	[ -s $fu_new ] || return
	if [ ! -f $dohconfig ]; then
		echo "`eval $D` Failed. https-dns-proxy config is not found." 
		return
	fi
	str_4b=$(str_bootstrap "$b_cr" "4")
	str_6b=$(str_bootstrap "$b_cr" "6")
	[ -z $str_4b ] && str_4b="119.29.29.29,223.5.5.5"
	[ -z $str_6b ] && str_6b="2400:3200::1,2400:3200:baba::1"
	/etc/init.d/https-dns-proxy enabled || /etc/init.d/https-dns-proxy enable
	/etc/init.d/https-dns-proxy stop >/dev/null 2>&1
	uci -q set https-dns-proxy.config.update_dnsmasq_config='-'
	if [ "$forcedoh" == "1" ]; then
		uci -q set https-dns-proxy.config.force_dns='1'
	else
		uci -q delete https-dns-proxy.config.force_dns
	fi
	clear_doh
	for i in $(cat $fu_new); do
		[ -z "$i" ] && continue
		hport=$(int_port $hport)
		if [ "$dohip4" == "1" -a "$dhoip6" == "1" ];then
			dohip6=0
		fi
		if [ "$dohip4" == "1" -o "$dohip6" == "0" ];then 
		uci -q add https-dns-proxy https-dns-proxy >/dev/null 2>&1
		uci -q set https-dns-proxy.@https-dns-proxy[-1].resolver_url="$i"
		uci -q set https-dns-proxy.@https-dns-proxy[-1].bootstrap_dns="$str_4b"
		uci -q set https-dns-proxy.@https-dns-proxy[-1].listen_port="$hport"
		uci -q set https-dns-proxy.@https-dns-proxy[-1].listen_addr="127.0.0.1"
		[ "$dohhttp" == "1" ] && uci -q set https-dns-proxy.@https-dns-proxy[-1].use_http1="1"
		fi
		if [ "$dohip4" == "0" ]; then
		uci -q add https-dns-proxy https-dns-proxy >/dev/null 2>&1
		uci -q set https-dns-proxy.@https-dns-proxy[-1].resolver_url="$i"
		uci -q set https-dns-proxy.@https-dns-proxy[-1].bootstrap_dns="$str_6b"
		uci -q set https-dns-proxy.@https-dns-proxy[-1].listen_port="$hport"
		uci -q set https-dns-proxy.@https-dns-proxy[-1].listen_addr='::1'
		[ "$dohhttp" == "1" ] && uci -q set https-dns-proxy.@https-dns-proxy[-1].use_http1="1"
		uci -q set https-dns-proxy.@https-dns-proxy[-1].use_ipv6_resolvers_only="1"
		fi
		let hport++
	done

	uci commit https-dns-proxy >/dev/null

	/etc/init.d/https-dns-proxy restart >/dev/null 2>&1

	get_nserver_cfg | sed "s/^/server=/" >> $mdhpconf
	grep -q "server=" $mdhpconf 2>/dev/null && dohon=1
	if [ -s $mdhpconf -a $dohon -eq 1 ]; then
		echo "`eval $D` DNS Over Https is on."
		[ "$dohhttp" == "1" ] && echo "`eval $D` But DoH will work on http1.1/tcp"
		[ "$dohip4" == "1" ] && echo "`eval $D` DoH force to IPv4 is set."
		[ "$dohip6" == "1" ] && echo "`eval $D` DoH force to IPv6 is set."
	else
		echo "`eval $D` DoH is not set."
	fi
	rm -rf $TPath
}

dns_conf(){
	local u_cr="$EPath/dns.mdhp"
	local fu_new="$TPath/user_doh"
	local dhcpe=0
	rm -f $fu_new
	[ -f $TPath ] && rm -f $TPath
	mkdir -p $TPath $SPath
	rm -f $mdhpconf
	rm -f $resolvconf
	clear_doh
	get_https $u_cr $fu_new
	which https-dns-proxy >/dev/null 2>&1 && dht=1
	[ -s $fu_new ] || dht=0
	if [ "$UDH" == "1" -a $dht -eq 1 ]; then
		user_doh
		if [ "$forcedoh" == "1" ]; then
			uci -q set dhcp.@dnsmasq[0].noresolv='1'
			uci -q delete dhcp.@dnsmasq[0].doh_backup_server
			uci -q delete dhcp.@dnsmasq[0].doh_backup_noresolv
		else
			uci -q delete dhcp.@dnsmasq[0].noresolv
		fi
		dhcpe=1
	fi

	[ "$forcedoh" == "1" -a "$UDH" == "1" ] || user_do53

	if [ -n "$dcache" ]; then
		uci set dhcp.@dnsmasq[0].cachesize=$dcache
		dhcpe=1
	fi
	if [ "$usemul" == "1" ];then
		uci -q set dhcp.@dnsmasq[0].allservers='1'
		dhcpe=1
	else
		uci -q delete dhcp.@dnsmasq[0].allservers
		dhcpe=1
	fi
	if [ "$dnssec" == "1" ];then
		[ "$(uci -q get dhcp.@dnsmasq[0].cachesize 2>/dev/null)" == "0" ] && uci -q set dhcp.@dnsmasq[0].cachesize='150'
		uci -q set dhcp.@dnsmasq[0].dnssec='1'
		uci -q set dhcp.@dnsmasq[0].dnsseccheckunsigned='0'
		dhcpe=1
	else
		uci -q delete dhcp.@dnsmasq[0].dnssec
		dhcpe=1
	fi
	[ $dhcpe -eq 1 ] && uci commit dhcp >/dev/null
}

ip_conf(){
	clear_iprule
	add_iprule
}

lnk_conf(){
	rm -rf $LPath
	mkdir -p $LPath
	[ -s $SPath/rules.conf ] && ln -sf $SPath/rules.conf $LPath/rules.conf
	[ -s $SPath/hosts.conf ] && ln -sf $SPath/hosts.conf $LPath/hosts.conf
	[ -s $SPath/user.conf ] && ln -sf $SPath/user.conf $LPath/user.conf
	[ -s $SPath/uhosts.conf ] && ln -sf $SPath/uhosts.conf $LPath/uhosts.conf
	[ -s $mdhpconf ] && ln -sf $mdhpconf $LPath/01.mdhp.conf
}

creat_hpconf(){
	local mincset=0
	set_DPath
	rm -f $helperconf
	echo "conf-dir=$LPath" >> $helperconf
	if [ -s $SPath/uhosts ]; then
		echo "addn-hosts=$SPath/uhosts" >> $helperconf
	fi
	if [ -s $resolvconf ]; then
		if [ $dht -eq 1 -a "$forcedoh" == "1" ];then
			sed -i "/resolv-file=/d" $helperconf
			uci -q delete dhcp.@dnsmasq[0].resolvfile
			uci commit dhcp
		else
			echo "resolv-file=$resolvconf" >> $helperconf
			#cat $resolvconf > $(get_rautoc)
			grep -q "resolv-file=" /etc/dnsmasq.conf && sed -i "/resolv-file=/d" /etc/dnsmasq.conf
			uci -q set dhcp.@dnsmasq[0].resolvfile="$resolvconf"
			uci commit dhcp
		fi
	elif [ "$(get_rautoc)" == "$resolvconf" ];then
		uci -q delete dhcp.@dnsmasq[0].resolvfile
		uci commit dhcp
	fi
	if [ "$dnslogon" == "1" ]; then
		echo "log-facility==$dnsmasqlog" >> $helperconf
		if [ "$dnslog" == "1" ];then
			uci -q delete dhcp.@dnsmasq[0].logqueries
			uci commit dhcp
			echo "log-queries=extra" >> $helperconf
			echo "log-async=10" >> $helperconf
		fi
		grep -q "log-" /etc/dnsmasq.conf && sed -i "/log-/d" /etc/dnsmasq.conf
	fi
	if [ "$filteraaaa" == "1" ];then
		echo "filter-AAAA" >> $helperconf
	fi
	if [ -n "$dcache" ];then
		if [ $dcache -gt 1000 ];then
			grep -q "min-cache-ttl" "$(get_dnsmasqcfg)" 2>/dev/null && mincset=1
			[ $mincset -eq 0 ] && echo "min-cache-ttl=3600" >> $helperconf
		fi
	fi
}

update_rules(){
	local j
	local du=0
	local da=0
	local dh=0
	echo "`eval $D` Rules reloading."
	read_count
	if [ $uprule -eq 1 -o ! -s $SPath/rules.conf -o "$(echo $UF | sed 's/ /\n/g' | sort -u)" != "$(cat $SPath/url 2>/dev/null)" ]; then
		downurl
		du=1
	fi
	if [ $uprule -eq 1 -o ! -s $SPath/white.txt -o "$(echo $UA | sed 's/ /\n/g' | sort -u)" != "$(cat $SPath/aurl 2>/dev/null)" ]; then
		downallow
		da=1
	fi
	if [ $uprule -eq 1 -o ! -s $SPath/hosts.conf -o "$(echo $UH | sed 's/ /\n/g' | sort -u)" != "$(cat $SPath/hurl 2>/dev/null)" ]; then
		downhosts
		dh=1
	fi
	user_rules

	if [ -s $SPath/white.txt -a -s $SPath/rules.conf ];then
		[ $da -eq 1 -o $du -eq 1 ] && lite_file $SPath/white.txt $SPath/rules.conf
	fi
	if [ -s $SPath/hosts.conf -a -s $SPath/rules.conf ];then
		get_domain_h $SPath/hosts.conf $SPath/hwhite.txt 
		[ $dh -eq 1 -o $du -eq 1 ] && lite_file $SPath/hwhite.txt $SPath/rules.conf
		rm -f $SPath/hwhite.txt
	fi
	if [ -s $SPath/uwhite.txt -a -s $SPath/rules.conf ];then
		if [ $(sed -r '/^$/d' $SPath/uwhite.txt 2>/dev/null | wc -l) -gt 800 ]; then
			lite_file $SPath/uwhite.txt $SPath/rules.conf
		else
			for i in `cat $SPath/uwhite.txt`; do
				j=`echo $i | sed -e 's/address=\///' -e 's/\/.*//'`
				sed -i -e "/\/$j\//d" -e "/\.$j\//d" $SPath/rules.conf
			done
		fi
	fi

	[ -s $SPath/rules.conf ] && sort_file $SPath/rules.conf
	for i in `ls $SPath/*.conf`;do
		sh /usr/share/my-dnshelper/checkconf $i
	done
	echo "$ifc,$iac,$ihc" > $countf
	if [ $du -eq 1 -o $da -eq 1 -o $dh -eq 1 ];then
		echo "`eval $D`" > $updatelog
	fi
	echo "`eval $D` Rules reload done."
}

maker_conf(){
	check_wgetcurl
	[ $upip -eq 1 ] && ip_conf
	[ $updns -eq 1 ] && dns_conf
	[ $uprule -ne -1 ] && update_rules
	echo "`eval $D` MY-Dnshelper Reload."
	#clean_wfiles
	lnk_conf
	creat_hpconf
	chmod_files
}

stopthis(){
	clean_wfiles
	clear_iprule
	[ -f $mdhpconf ] && clear_doh
	if [ "$(get_rautoc)" == "$resolvconf" ];then
		uci -q delete dhcp.@dnsmasq[0].resolvfile >/dev/null 2>&1
		uci -q delete dhcp.@dnsmasq[0].noresolv  >/dev/null 2>&1
		uci commit dhcp
	fi
}

if [ $Job -eq 0 ];then
	stopthis
else
	maker_conf
fi

echo "`eval $D` Dnsmasq restart."
/etc/init.d/dnsmasq restart >/dev/null 2>&1

if [ "$UDH" == "1" -a $dht -eq 1 ];then
	/etc/init.d/https-dns-proxy restart >/dev/null 2>&1
elif [ -f $mdhpconf -a "$EA" == "0" ];then
	/etc/init.d/https-dns-proxy stop >/dev/null 2>&1
elif [ "$EA" == "1" ];then
	/etc/init.d/https-dns-proxy stop >/dev/null 2>&1
	/etc/init.d/https-dns-proxy disable >/dev/null 2>&1
fi

exit 0
